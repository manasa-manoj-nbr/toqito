toqito.nonlocal_games.extended_nonlocal_game
============================================

.. py:module:: toqito.nonlocal_games.extended_nonlocal_game

.. autoapi-nested-parse::

   Two-player extended nonlocal game.





Module Contents
---------------

.. py:class:: ExtendedNonlocalGame(prob_mat, pred_mat, reps = 1)

   Create two-player extended nonlocal game object.

   *Extended nonlocal games* are a superset of nonlocal games in which the
   players share a tripartite state with the referee. In such games, the
   winning conditions for Alice and Bob may depend on outcomes of measurements
   made by the referee, on its part of the shared quantum state, in addition
   to Alice and Bob's answers to the questions sent by the referee.

   Extended nonlocal games were initially defined in :footcite:`Johnston_2016_Extended` and more
   information on these games can be found in :footcite:`Russo_2017_Extended`.

   For a detailed walkthrough and several examples, including the BB84 and CHSH
   games, please see the tutorial on :ref:`sphx_glr_auto_examples_extended_nonlocal_games`.

   .. rubric:: References

   .. footbibliography::


   .. py:method:: unentangled_value()

      Calculate the unentangled value of an extended nonlocal game.

      The *unentangled value* of an extended nonlocal game is the supremum
      value for Alice and Bob's winning probability in the game over all
      unentangled strategies. Due to convexity and compactness, it is possible
      to calculate the unentangled extended nonlocal game by:

      .. math::
          \omega(G) = \max_{f, g}
          \lVert
          \sum_{(x,y) \in \Sigma_A \times \Sigma_B} \pi(x,y)
          V(f(x), g(y)|x, y)
          \rVert

      where the maximum is over all functions :math:`f : \Sigma_A \rightarrow
      \Gamma_A` and :math:`g : \Sigma_B \rightarrow \Gamma_B`.

      :return: The unentangled value of the extended nonlocal game.



   .. py:method:: nonsignaling_value()

      Calculate the non-signaling value of an extended nonlocal game.

      The *non-signaling value* of an extended nonlocal game is the supremum
      value of the winning probability of the game taken over all
      non-signaling strategies for Alice and Bob.

      A *non-signaling strategy* for an extended nonlocal game consists of a
      function

      .. math::
          K : \Gamma_A \times \Gamma_B \times \Sigma_A \times \Sigma_B
          \rightarrow \text{Pos}(\mathcal{R})

      such that

      .. math::
          \sum_{a \in \Gamma_A} K(a,b|x,y) = \rho_b^y
          \quad \text{and} \quad
          \sum_{b \in \Gamma_B} K(a,b|x,y) = \sigma_a^x,

      for all :math:`x \in \Sigma_A` and :math:`y \in \Sigma_B` where
      :math:`\{\rho_b^y : y \in \Sigma_A, \ b \in \Gamma_B\}` and
      :math:`\{\sigma_a^x : x \in \Sigma_A, \ a \in \Gamma_B\}` are
      collections of operators satisfying

      .. math::
          \sum_{a \in \Gamma_A} \rho_b^y =
          \tau =
          \sum_{b \in \Gamma_B} \sigma_a^x,

      for every choice of :math:`x \in \Sigma_A` and :math:`y \in \Sigma_B`
      where :math:`\tau \in \text{D}(\mathcal{R})` is a density operator.

      :return: The non-signaling value of the extended nonlocal game.



   .. py:method:: quantum_value_lower_bound(iters = 20, tol = 1e-08, seed = None, initial_bob_is_random = False, solver = cvxpy.SCS, solver_params = None, verbose = False)

      Calculate lower bound on the quantum value of an extended nonlocal game.

      Uses an iterative see-saw method involving two SDPs.

      :param iter: Maximum number of see-saw iterations (Alice optimizes, Bob optimizes (default is 20).
      :param tol: Tolerance for stopping see-saw iteration based on improvement (default is 1e-8).
      :param seed: Optional seed for initializing random POVMs for reproducibility (default is None).
      :param solver: Optional option for different solver (default is SCS).
      :param solver_params: Optional parameters for solver (default is {"eps": 1e-8, "verbose": False}).
      :param verbos: Optional printout for optimizer step (default is False).
      :return: The best lower bound found on the quantum value.



   .. py:method:: commuting_measurement_value_upper_bound(k = 1, no_signaling = True)

      Compute an upper bound on the commuting measurement value of an extended nonlocal game.

      This function calculates an upper bound on the commuting measurement value by
      using k-levels of the NPA hierarchy :footcite:`Navascues_2008_AConvergent`. The NPA hierarchy is a uniform
      family of semidefinite programs that converges to the commuting measurement value of
      any extended nonlocal game.

      You can determine the level of the hierarchy by a positive integer or a string
      of a form like '1+ab+aab', which indicates that an intermediate level of the hierarchy
      should be used, where this example uses all products of one measurement, all products of
      one Alice and one Bob measurement, and all products of two Alice and one Bob measurements.

      .. rubric:: References

      .. footbibliography::

      :param k: The level of the NPA hierarchy to use (default=1).
      :return: The upper bound on the commuting strategy value of an extended nonlocal game.




